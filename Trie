ğŸš€ Tries (Prefix Tree) Roadmap
Tries are used for string matching, autocomplete, spell checking, and prefix-based queries.

Level	Topics & Problems
ğŸŸ¢ Basic	âœ… Implement Trie (Insert, Search, StartsWith)
âœ… Count words with given prefix
âœ… Delete a word from Trie
âš¡ Intermediate	âœ… Longest Prefix Matching
âœ… Auto-suggestion feature
âœ… Count Distinct Substrings
ğŸ”¥ Advanced (FAANG)	âœ… Word Search II (Leetcode 212)
âœ… Palindrome Pairs (Leetcode 336)
âœ… Maximum XOR Pair (Leetcode 421)
âœ… Replace Words (Leetcode 648)

ğŸ“ Important Interview Questions
Problem	Level	Platform
Implement Trie (Insert, Search, StartsWith)	ğŸŸ¢ Basic	Leetcode 208
Delete a Word from Trie	ğŸŸ¢ Basic	GFG
Count words with a given Prefix	ğŸŸ¢ Basic	GFG
Longest Prefix Matching	âš¡ Medium	GFG
Auto-suggestion System	âš¡ Medium	GFG
Count Distinct Substrings using Trie	âš¡ Medium	InterviewBit
Word Search II (Backtracking + Trie)	ğŸ”¥ Hard	Leetcode 212
Palindrome Pairs	ğŸ”¥ Hard	Leetcode 336
Maximum XOR of Two Numbers in an Array	ğŸ”¥ Hard	Leetcode 421
Replace Words (for dictionary compression)	ğŸ”¥ Hard	Leetcode 648

ğŸ§  Why Tries are Important for Interviews?
âœ… Faster than hash maps for prefix-based queries
âœ… Used in Autocomplete, Spell Checker, IP Routing, T9 Predictive Text
âœ… Frequently asked in Google, Amazon, Microsoft, Facebook

ğŸ§‘ğŸ»â€ğŸ’» All-in-One Python Code for Tries
python
Copy
Edit
# ========================
# ğŸŸ¢ BASIC TRIE OPERATIONS
# ========================

class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    # Insert word into trie
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    # Search for a complete word
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    # Check if any word starts with the given prefix
    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

    # Delete a word from Trie
    def delete(self, word):
        def _delete(node, word, depth):
            if not node:
                return False
            if depth == len(word):
                if node.is_end_of_word:
                    node.is_end_of_word = False
                    return len(node.children) == 0
                return False
            char = word[depth]
            if char in node.children:
                should_delete = _delete(node.children[char], word, depth + 1)
                if should_delete:
                    del node.children[char]
                    return len(node.children) == 0 and not node.is_end_of_word
            return False

        _delete(self.root, word, 0)


# ========================
# âš¡ INTERMEDIATE
# ========================

# Longest Prefix Matching
def longest_prefix(trie, word):
    prefix = ""
    node = trie.root
    for char in word:
        if char in node.children:
            prefix += char
            node = node.children[char]
        else:
            break
    return prefix


# Count Distinct Substrings
class DistinctSubstringTrie:
    def __init__(self):
        self.root = TrieNode()

    def insert_suffixes(self, s):
        count = 0
        for i in range(len(s)):
            node = self.root
            for j in range(i, len(s)):
                if s[j] not in node.children:
                    node.children[s[j]] = TrieNode()
                    count += 1
                node = node.children[s[j]]
        return count


# ========================
# ğŸ”¥ ADVANCED
# ========================

# Leetcode 212: Word Search II
def find_words(board, words):
    trie = Trie()
    for word in words:
        trie.insert(word)
    rows, cols = len(board), len(board[0])
    result = set()

    def dfs(r, c, node, path):
        if node.is_end_of_word:
            result.add(path)
        if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] not in node.children:
            return
        char = board[r][c]
        board[r][c] = "#"  # mark visited
        for dr, dc in [(0,1), (1,0), (-1,0), (0,-1)]:
            dfs(r+dr, c+dc, node.children[char], path+char)
        board[r][c] = char  # backtrack

    for r in range(rows):
        for c in range(cols):
            dfs(r, c, trie.root, "")
    return list(result)


# ========================
# ğŸš€ TEST CASES
# ========================
if __name__ == "__main__":
    print("âœ… Basic Trie Operations")
    trie = Trie()
    trie.insert("apple")
    trie.insert("app")
    print("Search 'apple':", trie.search("apple"))  # True
    print("Search 'app':", trie.search("app"))      # True
    print("StartsWith 'ap':", trie.starts_with("ap"))  # True
    trie.delete("app")
    print("Search 'app' after delete:", trie.search("app"))  # False

    print("\nâš¡ Longest Prefix Matching")
    print("Longest prefix of 'applause':", longest_prefix(trie, "applause"))

    print("\nâš¡ Count Distinct Substrings")
    dst = DistinctSubstringTrie()
    print("Distinct substrings in 'abc':", dst.insert_suffixes("abc"))  # 6

    print("\nğŸ”¥ Word Search II")
    board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]]
    words = ["oath","pea","eat","rain"]
    print("Found words:", find_words(board, words))  # ['oath', 'eat']
